#!/bin/sh
# Commit-msg hook para FisioFlow
# Valida o formato das mensagens de commit

set -e

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fun√ß√£o para imprimir com cor
print_color() {
    printf "${1}${2}${NC}\n"
}

# Arquivo da mensagem de commit
commit_msg_file="$1"
commit_msg=$(cat "$commit_msg_file")

# Ignorar commits de merge
if echo "$commit_msg" | grep -q "^Merge "; then
    print_color $BLUE "üîÄ Commit de merge detectado, pulando valida√ß√£o"
    exit 0
fi

# Ignorar commits de revert
if echo "$commit_msg" | grep -q "^Revert "; then
    print_color $BLUE "‚Ü©Ô∏è  Commit de revert detectado, pulando valida√ß√£o"
    exit 0
fi

# Ignorar commits autom√°ticos do GitHub
if echo "$commit_msg" | grep -qE "^(Initial commit|Update .*\.md|Create .*)"; then
    print_color $BLUE "ü§ñ Commit autom√°tico detectado, pulando valida√ß√£o"
    exit 0
fi

print_color $BLUE "üìù Validando mensagem de commit..."

# Extrair a primeira linha (t√≠tulo)
title=$(echo "$commit_msg" | head -n1)

# Verificar se a primeira linha n√£o est√° vazia
if [ -z "$title" ]; then
    print_color $RED "‚ùå Mensagem de commit vazia!"
    exit 1
fi

# Verificar comprimento do t√≠tulo (m√°ximo 50 caracteres)
if [ ${#title} -gt 50 ]; then
    print_color $RED "‚ùå T√≠tulo muito longo (${#title} caracteres, m√°ximo 50)"
    print_color $YELLOW "üí° T√≠tulo atual: $title"
    exit 1
fi

# Padr√£o Conventional Commits
# Formato: tipo(escopo): descri√ß√£o
conventional_pattern="^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\\([a-z0-9-]+\\))?: .+"

if ! echo "$title" | grep -qE "$conventional_pattern"; then
    print_color $RED "‚ùå Formato de commit inv√°lido!"
    print_color $YELLOW "üìã Formato esperado: tipo(escopo): descri√ß√£o"
    print_color $YELLOW "üè∑Ô∏è  Tipos v√°lidos:"
    print_color $YELLOW "   ‚Ä¢ feat:     Nova funcionalidade"
    print_color $YELLOW "   ‚Ä¢ fix:      Corre√ß√£o de bug"
    print_color $YELLOW "   ‚Ä¢ docs:     Documenta√ß√£o"
    print_color $YELLOW "   ‚Ä¢ style:    Formata√ß√£o (sem mudan√ßa de c√≥digo)"
    print_color $YELLOW "   ‚Ä¢ refactor: Refatora√ß√£o de c√≥digo"
    print_color $YELLOW "   ‚Ä¢ test:     Testes"
    print_color $YELLOW "   ‚Ä¢ chore:    Tarefas de build, configura√ß√£o"
    print_color $YELLOW "   ‚Ä¢ perf:     Melhoria de performance"
    print_color $YELLOW "   ‚Ä¢ ci:       Configura√ß√£o de CI"
    print_color $YELLOW "   ‚Ä¢ build:    Sistema de build"
    print_color $YELLOW "   ‚Ä¢ revert:   Reverter commit"
    print_color $YELLOW "üìù Exemplos:"
    print_color $YELLOW "   ‚Ä¢ feat(auth): adicionar login com Google"
    print_color $YELLOW "   ‚Ä¢ fix(ui): corrigir layout responsivo"
    print_color $YELLOW "   ‚Ä¢ docs(api): atualizar documenta√ß√£o"
    print_color $YELLOW "üí° T√≠tulo atual: $title"
    exit 1
fi

# Extrair tipo e escopo
type=$(echo "$title" | sed -E 's/^([a-z]+)(\\([^)]+\\))?: .*/\\1/')
scope=$(echo "$title" | sed -E 's/^[a-z]+(\\(([^)]+)\\))?: .*/\\2/')
description=$(echo "$title" | sed -E 's/^[a-z]+(\\([^)]+\\))?: (.*)/\\3/')

# Verificar se a descri√ß√£o come√ßa com letra min√∫scula
first_char=$(echo "$description" | cut -c1)
if echo "$first_char" | grep -q '[A-Z]'; then
    print_color $RED "‚ùå Descri√ß√£o deve come√ßar com letra min√∫scula"
    print_color $YELLOW "üí° Atual: $description"
    print_color $YELLOW "üí° Sugest√£o: $(echo "$description" | sed 's/^./\L&/')"
    exit 1
fi

# Verificar se a descri√ß√£o termina com ponto
if echo "$description" | grep -q '\.$'; then
    print_color $RED "‚ùå Descri√ß√£o n√£o deve terminar com ponto"
    print_color $YELLOW "üí° Atual: $description"
    print_color $YELLOW "üí° Sugest√£o: $(echo "$description" | sed 's/\.$$//')"
    exit 1
fi

# Verificar se usa imperativo (algumas verifica√ß√µes b√°sicas)
imperative_violations=(
    "adicionado|removido|corrigido|atualizado|implementado"
    "added|removed|fixed|updated|implemented"
)

for violation in "${imperative_violations[@]}"; do
    if echo "$description" | grep -qiE "$violation"; then
        print_color $YELLOW "‚ö†Ô∏è  Poss√≠vel uso de partic√≠pio passado detectado"
        print_color $YELLOW "üí° Use o imperativo: 'adicionar' em vez de 'adicionado'"
        print_color $YELLOW "üí° Descri√ß√£o atual: $description"
        break
    fi
done

# Verificar escopos sugeridos para o projeto
valid_scopes=(
    "auth" "ui" "api" "db" "config" "deps" "mobile" "web" "tests" 
    "docs" "deploy" "security" "perf" "a11y" "i18n" "freemium" "ios"
)

if [ ! -z "$scope" ]; then
    scope_valid=false
    for valid_scope in "${valid_scopes[@]}"; do
        if [ "$scope" = "$valid_scope" ]; then
            scope_valid=true
            break
        fi
    done
    
    if [ "$scope_valid" = false ]; then
        print_color $YELLOW "‚ö†Ô∏è  Escopo '$scope' n√£o est√° na lista de escopos sugeridos"
        print_color $YELLOW "üìã Escopos sugeridos: ${valid_scopes[*]}"
        print_color $YELLOW "üí° Voc√™ pode continuar, mas considere usar um escopo padr√£o"
    fi
fi

# Verificar corpo da mensagem (se existir)
body=$(echo "$commit_msg" | tail -n +3)
if [ ! -z "$body" ]; then
    # Verificar se h√° linha em branco entre t√≠tulo e corpo
    second_line=$(echo "$commit_msg" | sed -n '2p')
    if [ ! -z "$second_line" ]; then
        print_color $RED "‚ùå Deve haver uma linha em branco entre t√≠tulo e corpo"
        exit 1
    fi
    
    # Verificar comprimento das linhas do corpo (m√°ximo 72 caracteres)
    echo "$body" | while IFS= read -r line; do
        if [ ${#line} -gt 72 ]; then
            print_color $YELLOW "‚ö†Ô∏è  Linha do corpo muito longa (${#line} caracteres, m√°ximo 72)"
            print_color $YELLOW "üí° Linha: $line"
        fi
    done
fi

# Verificar breaking changes
if echo "$commit_msg" | grep -q "BREAKING CHANGE:"; then
    print_color $YELLOW "‚ö†Ô∏è  Breaking change detectado!"
    print_color $YELLOW "üí° Certifique-se de documentar adequadamente"
fi

# Verificar refer√™ncias a issues
if echo "$commit_msg" | grep -qE "(Closes|Fixes|Resolves) #[0-9]+"; then
    print_color $GREEN "‚úÖ Refer√™ncia a issue encontrada"
fi

# Verificar palavras proibidas
prohibited_words=("fuck" "shit" "damn" "crap" "stupid" "dumb" "wtf" "omg")
for word in "${prohibited_words[@]}"; do
    if echo "$commit_msg" | grep -qi "$word"; then
        print_color $RED "‚ùå Linguagem inapropriada detectada: $word"
        print_color $YELLOW "üí° Mantenha as mensagens de commit profissionais"
        exit 1
    fi
done

# Verificar se √© um commit de WIP
if echo "$title" | grep -qi "wip\|work in progress\|todo\|fixme"; then
    print_color $YELLOW "‚ö†Ô∏è  Commit WIP detectado"
    print_color $YELLOW "üí° Lembre-se de fazer squash antes do merge"
fi

print_color $GREEN "‚úÖ Mensagem de commit v√°lida!"
print_color $BLUE "üìã Tipo: $type"
if [ ! -z "$scope" ]; then
    print_color $BLUE "üè∑Ô∏è  Escopo: $scope"
fi
print_color $BLUE "üìù Descri√ß√£o: $description"

exit 0